import chalk from 'chalk';
import * as fs from 'fs-extra';
import ignore from 'ignore';
import * as os from 'os';
import * as path from 'path';

export interface IndexIgnoreOptions {
  exclude: string[];
}

const commont = `/* Generated by cli, don't modify manually */`;
const space = `${os.EOL}${os.EOL}`;

type IndexGeneratorOptions = {
  force: boolean;
  js: boolean;
  ignore: string;
};

type ConvertOptions = {
  dirUrl: string;
  dirName: string;
  ext: string;
  template: string;
  absoluteFilePath: string;
};

export class IndexGenerator {
  url: string;
  isforce: boolean;
  isModule: boolean;
  isJs: boolean;
  ignore: IndexIgnoreOptions;

  ig = ignore();

  constructor(target: string, options: IndexGeneratorOptions) {
    this.url = target;
    this.isforce = options.force;
    this.isJs = options.js;

    if (fs.existsSync(options.ignore)) {
      this.ignore = require(options.ignore);

      this.ig.add(this.ignore.exclude);
    }
  }

  createFile(dirUrl?: string) {
    if (!dirUrl) {
      dirUrl = this.url;
    }
    const filePaths = fs.readdirSync(dirUrl);

    const exportDefaultContentObj = new Set();
    const exportObjectContentObj = new Set();
    const importContentObj = new Set();

    const ext = this.isJs ? 'js' : 'ts';

    const targetUrl = path.join(dirUrl, `index.${ext}`);

    const dirName = path.basename(dirUrl);

    let exportCount = 0;

    filePaths.forEach(filePath => {
      const absoluteFilePath = path.join(dirUrl, filePath);

      if (this.checkPathVariable(absoluteFilePath) || filePath === 'scss') {
        return 0;
      }

      const status = fs.statSync(absoluteFilePath);
      const isDir = status.isDirectory();

      let currentDirCount = 0;

      // check is dir
      if (isDir) {
        currentDirCount = this.createFile(absoluteFilePath);
        exportCount += currentDirCount;

        if (exportCount > 0) {
          const dirIndex = path.join(absoluteFilePath, `index.${ext}`);

          if (fs.existsSync(dirIndex)) {
            const content = fs.readFileSync(dirIndex).toString();

            if (this.hasDefault(content)) {
              importContentObj.add(`import ${filePath} from './${filePath}';`);
              exportObjectContentObj.add(filePath);

              if (this.checkHasOtherExport(content)) {
                exportDefaultContentObj.add(`export * from './${filePath}';`);
              }
            } else {
              exportDefaultContentObj.add(`export * from './${filePath}';`);
            }
          }
        }
      } else {
        if (this.skipInvalidFiles(ext, filePath)) {
          return 0;
        }

        filePath = filePath.replace(new RegExp(`\.${ext}$`, 'gi'), '');

        const content = fs.readFileSync(absoluteFilePath).toString();
        if (!content) {
          return 0;
        }

        if (filePath === 'index') {
          // if there has index and the index has content, create an file with current dir and
          if (!content.includes(commont)) {
            if (
              this.convertIndexToFile({
                dirUrl,
                dirName,
                ext,
                template: content,
                absoluteFilePath
              })
            ) {
              importContentObj.add(`import ${dirName} from './${dirName}';`);
              exportDefaultContentObj.add(`export default ${dirName};`);

              if (this.checkHasOtherExport(content)) {
                exportDefaultContentObj.add(`export * from './${filePath}';`);
              }
              exportCount++;
            }
          }
          return exportCount;
        }

        if (this.hasDefault(content)) {
          importContentObj.add(`import ${filePath} from './${filePath}';`);

          if (filePath === dirName) {
            exportDefaultContentObj.add(`export default ${filePath};`);
          } else {
            exportObjectContentObj.add(filePath);
          }

          // check file has other export
          if (this.checkHasOtherExport(content)) {
            exportDefaultContentObj.add(`export * from './${filePath}';`);
          }
        } else {
          exportDefaultContentObj.add(`export * from './${filePath}';`);
        }
        exportCount++;
      }
    });

    if (exportCount > 0) {
      if (fs.existsSync(targetUrl)) {
        if (!this.isforce) {
          console.log(`${chalk.red('existed ')} ${targetUrl}`);
          return 0;
        }
        console.log(`${chalk.yellow('update ')} ${targetUrl}`);
      } else {
        console.log(`${chalk.green('create ')} ${targetUrl}`);
      }

      fs.writeFileSync(
        targetUrl,
        commont +
          os.EOL +
          [...importContentObj].join(os.EOL) +
          os.EOL +
          exportObject(exportObjectContentObj) +
          os.EOL +
          [...exportDefaultContentObj].join(os.EOL)
      );
    }

    return exportCount;
  }

  private hasDefault(content: string) {
    return content.includes('export default') || content.includes('as default');
  }

  private checkHasOtherExport(content: string) {
    return content
      .replace(/export default|as default/gi, '')
      .includes('export ');
  }

  private convertIndexToFile({
    dirUrl,
    dirName,
    ext,
    template,
    absoluteFilePath
  }: ConvertOptions) {
    const dirTargetUrl = path.join(dirUrl, `${dirName}.${ext}`);
    if (!fs.existsSync(dirTargetUrl)) {
      fs.writeFileSync(dirTargetUrl, template);
      console.log(
        `${chalk.yellow(
          'rename file: '
        )} ${absoluteFilePath} => ${dirTargetUrl}`
      );
      return true;
    } else {
      return false;
    }
  }

  private skipInvalidFiles(ext: string, filePath: string) {
    return (
      !new RegExp(`\.${ext}$`, 'gi').test(filePath) ||
      new RegExp(`\.spec\.${ext}$`, 'gi').test(filePath) ||
      new RegExp(`^_`, 'gi').test(filePath) ||
      new RegExp(`\.test\.${ext}$`, 'gi').test(filePath) ||
      (!this.isJs && new RegExp(`^index\.${ext}$`, 'gi').test(filePath))
    );
  }

  private checkPathVariable(fileUrl: string) {
    let checkUrl = fileUrl;
    if (checkUrl[0] === '/') {
      checkUrl = checkUrl.substring(1);
    }
    return (
      this.ignore &&
      (this.ignore.exclude && this.ig.ignores(path.join(checkUrl)))
    );
  }
}
function exportObject(exportObjectContentObj: Set<unknown>) {
  return exportObjectContentObj.size > 0
    ? `export {
  ${[...exportObjectContentObj].join(',' + os.EOL + '  ')}
}`
    : '';
}
