import chalk from 'chalk';
import * as fs from 'fs-extra';
import ignore from 'ignore';
import * as os from 'os';
import * as path from 'path';

import { BaseModel } from '../model';

interface IndexIgnoreOptions {
  exclude: string[];
}

const commont = `/*
* Generated by cli, don't modify manually
*/`;
const space = `${os.EOL}${os.EOL}`;

export class IndexGenerator {
  _url: string;
  isforce: boolean;
  isModule: boolean;
  isJs: boolean;
  ignore: IndexIgnoreOptions;

  ig = ignore();

  constructor(model: BaseModel) {
    this._url = model.targetUrl;

    this.analysisArgs(model);
  }

  private analysisArgs(model: BaseModel) {
    model.config.forEach((arg) => {
      if (arg.includes('--force')) {
        this.isforce = true;
        return;
      }
      if (arg.includes('--m')) {
        this.isModule = true;
        return;
      }
      if (arg.includes('--js')) {
        this.isJs = true;
        return;
      }
      if (arg.includes('--ignore=')) {
        const url = arg.replace('--ignore=', '');
        if (fs.existsSync(url)) {
          this.ignore = require(url);

          this.ig.add(this.ignore.exclude);

          // console.log(this.ig.ignores('/i18n/sdf'));
        }
        return;
      }
    });
  }

  createFile(dirUrl?: string) {
    if (!dirUrl) {
      dirUrl = this._url;
    }
    const files = fs.readdirSync(dirUrl);

    const exportContentObj = new Set();
    const importContentObj = new Set();

    let hasDirFile = false;
    const ext = this.isJs ? 'js' : 'ts';

    const targetUrl = path.join(dirUrl, `index.${ext}`);

    const dirName = path.basename(dirUrl);

    let exportCount = 0;
    files.forEach(file => {
      const fileUrl = path.join(dirUrl, file);

      if (this.checkUrlPass(fileUrl)) {
        return 0;
      }

      const stats = fs.statSync(fileUrl);
      const isDir = stats.isDirectory();

      let currentDirCount = 0;
      if (file === 'scss') {
        console.log('stop');
      }
      if (isDir) {
        currentDirCount = this.createFile(fileUrl);
        exportCount += currentDirCount;
      } else {
        if (
          !new RegExp(`\.${ext}$`, 'gi').test(file) ||
          new RegExp(`\.spec\.${ext}$`, 'gi').test(file) ||
          new RegExp(`^_`, 'gi').test(file) ||
          new RegExp(`\.test\.${ext}$`, 'gi').test(file) ||
          (!this.isJs && new RegExp(`^index\.${ext}$`, 'gi').test(file)) ||
          (!this.isModule && new RegExp(`\.module\.${ext}$`, 'gi').test(file))
        ) {
          return;
        }
        file = file.replace(new RegExp(`\.${ext}$`, 'gi'), '');
        if (file === 'index') {

          const template = fs.readFileSync(fileUrl).toString();

          // if there has index and the index has content, create an file with current dir and
          if (!template.includes(commont)) {
            const dirTargetUrl = path.join(dirUrl, `${dirName}.js`);
            if (!fs.existsSync(dirTargetUrl)) {
              fs.writeFileSync(dirTargetUrl, template);
              console.log(`${chalk.yellow('rename file: ')} ${fileUrl} => ${dirTargetUrl}`);
            }
            exportCount++;
            importContentObj.add(`import ${dirName} from './${dirName}';`);
            hasDirFile = true;
          }
          return;
        }
      }

      if (this.isJs) {
        if (!isDir) {
          const content = fs.readFileSync(fileUrl).toString();
          if (content) {
            if (content.includes('export default')) {

              if (file === dirName) {
                importContentObj.add(`import ${file} from './${file}';`);
                hasDirFile = true;
              } else {
                exportContentObj.add(`export ${file} from './${file}';`);
              }
            } else {
              exportContentObj.add(`export * from './${file}';`);
            }
            exportCount++;
          }
        } else if (currentDirCount > 0) {
          exportContentObj.add(`export ${file} from './${file}';`);
          exportCount++;
        }
      } else {
        exportContentObj.add(`export * from './${file}';`);
        exportCount++;
      }
    });

    if (exportCount > 0) {
      if (fs.existsSync(targetUrl)) {
        if (!this.isforce) {
          console.log(`${chalk.red('existed ')} ${targetUrl}`);
          return;
        }
        console.log(`${chalk.yellow('update ')} ${targetUrl}`);
      } else {
        console.log(`${chalk.green('create ')} ${targetUrl}`);
      }


      fs.writeFileSync(targetUrl,
        commont + os.EOL +
        [...importContentObj].join(os.EOL) +
        (importContentObj.size > 0 ? space : '') +
        [...exportContentObj].join(os.EOL) +
        (exportContentObj.size > 0 ? (hasDirFile ? space : os.EOL) : '') +
        (hasDirFile ? `export default ${dirName};${os.EOL}` : '')
      );
    }

    return exportCount;
  }


  private checkUrlPass(fileUrl: string) {
    let checkUrl = fileUrl;
    if (checkUrl[0] === '/') {
      checkUrl = checkUrl.substring(1);
    }
    return this.ignore &&
      (this.ignore.exclude && this.ig.ignores(path.join(checkUrl)));
  }
}

